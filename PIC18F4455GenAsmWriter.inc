//===- TableGen'erated file -------------------------------------*- C++ -*-===//
//
// Assembly Writer Source Fragment
//
// Automatically generated file, do not edit!
//
//===----------------------------------------------------------------------===//

/// printInstruction - This method is automatically generated by tablegen
/// from the instruction set description.
void PIC18F4455AsmPrinter::printInstruction(const MachineInstr *MI, raw_ostream &O) {
  static const unsigned OpInfo[] = {
    0U,	// PHI
    0U,	// INLINEASM
    0U,	// PROLOG_LABEL
    0U,	// EH_LABEL
    0U,	// GC_LABEL
    0U,	// KILL
    0U,	// EXTRACT_SUBREG
    0U,	// INSERT_SUBREG
    0U,	// IMPLICIT_DEF
    0U,	// SUBREG_TO_REG
    0U,	// COPY_TO_REGCLASS
    1U,	// DBG_VALUE
    0U,	// REG_SEQUENCE
    0U,	// COPY
    11U,	// ADJCALLSTACKDOWN
    29U,	// ADJCALLSTACKUP
    536870957U,	// AndFW
    1073741869U,	// AndWF
    1677721652U,	// CALL
    2302672954U,	// MOV8rr
    1677721665U,	// MOV8rs
    1811939408U,	// MOV8rw
    1879048250U,	// MOV8sr
    87U,	// MOV8sw
    2306867302U,	// MOV8wr
    108U,	// MOV8ws
    536871035U,	// OrFW
    1073741947U,	// OrWF
    1677721730U,	// Retlw
    137U,	// Return
    144U,	// SELECT_CC_Int_ICC
    536871084U,	// XOrFW
    1073741996U,	// XOrWF
    536871091U,	// addfw_1
    536871091U,	// addfw_2
    536871098U,	// addfwc
    1140850882U,	// addlw_1
    1140850882U,	// addlw_2
    1140850889U,	// addlwc
    1073742003U,	// addwf_1
    1073742003U,	// addwf_2
    1073742010U,	// addwfc
    1140850897U,	// andlw
    1677721816U,	// br_uncond
    1749024990U,	// copy_fsr
    1749025000U,	// copy_w
    1409286384U,	// load_indirect
    1086324983U,	// movf
    1086324983U,	// movf_1
    1086324983U,	// movf_1_1
    1086324983U,	// movf_2
    2214592765U,	// movlw
    2181038340U,	// movlw_hi_1
    2181038340U,	// movlw_hi_2
    2181038352U,	// movlw_lo_1
    2181038352U,	// movlw_lo_2
    1077936411U,	// movwf
    1077936411U,	// movwf_1
    1077936411U,	// movwf_2
    1140850978U,	// orlw
    2684354857U,	// pic18f4455brcond
    1212154155U,	// restore_fsr0
    1212154169U,	// restore_fsr1
    1212154183U,	// save_fsr0
    1212154194U,	// save_fsr1
    2013266203U,	// set_fsrhi
    2080375067U,	// set_fsrlo
    1677721883U,	// set_pclath
    1409286493U,	// store_indirect
    536871268U,	// subfw_1
    536871268U,	// subfw_2
    536871268U,	// subfw_cc
    536871275U,	// subfwb
    1140851059U,	// sublw_1
    1140851059U,	// sublw_2
    1140851066U,	// sublw_3
    1140851074U,	// sublw_4
    1140851074U,	// sublw_5
    1140851081U,	// sublw_6
    1140851059U,	// sublw_cc
    1077936484U,	// subwf_1
    1077936484U,	// subwf_2
    1077936484U,	// subwf_cc
    1077936491U,	// subwfb
    1140851089U,	// xorlw
    0U
  };

  const char *AsmStrs = 
    "DBG_VALUE\000#ADJCALLSTACKDOWN\000#ADJCALLSTACKUP\000andwf \000call\t\000"
    "movff\t\000movff\tPREINC0,\000movwf\t\000movwf\tPOSTDEC0\000movf\t\000m"
    "ovf\tPREINC0,W\000iorwf \000retlw \000return\000; SELECT_CC_Int_ICC PSE"
    "UDO!\000xorwf \000addwf \000addwfc \000addlw \000addlwc \000andlw \000g"
    "oto \000copy_fsr \000copy_w \000moviw \000movf \000movlw \000movlw HIGH"
    "(\000movlw LOW(\000movwf \000iorlw \000b\000restore_fsr0 \000restore_fs"
    "r1 \000save_fsr0 \000save_fsr1 \000movwi \000subwf \000subwfb \000sublw"
    " \000sublwb \000subwl \000subwlb \000xorlw \000";

  O << "\t";

  // Emit the opcode for the instruction.
  unsigned Bits = OpInfo[MI->getOpcode()];
  assert(Bits != 0 && "Cannot print this instruction.");
  O << AsmStrs+(Bits & 511)-1;


  // Fragment 0 encoded into 3 bits for 6 unique commands.
  switch ((Bits >> 29) & 7) {
  default:   // unreachable.
  case 0:
    // DBG_VALUE, ADJCALLSTACKDOWN, ADJCALLSTACKUP, MOV8sw, MOV8ws, Return, S...
    return;
    break;
  case 1:
    // AndFW, OrFW, XOrFW, addfw_1, addfw_2, addfwc, subfw_1, subfw_2, subfw_...
    printOperand(MI, 3, O); 
    O << " + "; 
    printOperand(MI, 2, O); 
    O << ", W"; 
    return;
    break;
  case 2:
    // AndWF, OrWF, XOrWF, addlw_1, addlw_2, addlwc, addwf_1, addwf_2, addwfc...
    printOperand(MI, 2, O); 
    break;
  case 3:
    // CALL, MOV8rs, MOV8rw, MOV8sr, Retlw, br_uncond, copy_fsr, copy_w, set_...
    printOperand(MI, 0, O); 
    break;
  case 4:
    // MOV8rr, MOV8wr, movlw, movlw_hi_1, movlw_hi_2, movlw_lo_1, movlw_lo_2
    printOperand(MI, 1, O); 
    break;
  case 5:
    // pic18f4455brcond
    printCCOperand(MI, 1, O); 
    O << ' '; 
    printOperand(MI, 0, O); 
    return;
    break;
  }


  // Fragment 1 encoded into 3 bits for 8 unique commands.
  switch ((Bits >> 26) & 7) {
  default:   // unreachable.
  case 0:
    // AndWF, OrWF, XOrWF, addwf_1, addwf_2, addwfc, movf, movf_1, movf_1_1, ...
    O << " + "; 
    break;
  case 1:
    // CALL, MOV8rs, Retlw, addlw_1, addlw_2, addlwc, andlw, br_uncond, movlw...
    return;
    break;
  case 2:
    // MOV8rr, MOV8wr, copy_fsr, copy_w, restore_fsr0, restore_fsr1, save_fsr...
    O << ", "; 
    break;
  case 3:
    // MOV8rw
    O << ",BANKED"; 
    return;
    break;
  case 4:
    // MOV8sr
    O << ",POSTDEC0"; 
    return;
    break;
  case 5:
    // load_indirect, store_indirect
    O << '['; 
    printOperand(MI, 1, O); 
    O << ']'; 
    return;
    break;
  case 6:
    // set_fsrhi
    O << 'H'; 
    return;
    break;
  case 7:
    // set_fsrlo
    O << 'L'; 
    return;
    break;
  }


  // Fragment 2 encoded into 2 bits for 3 unique commands.
  switch ((Bits >> 24) & 3) {
  default:   // unreachable.
  case 0:
    // AndWF, OrWF, XOrWF, addwf_1, addwf_2, addwfc, copy_fsr, copy_w, movf, ...
    printOperand(MI, 1, O); 
    break;
  case 1:
    // MOV8rr, MOV8wr
    printOperand(MI, 0, O); 
    break;
  case 2:
    // movlw_hi_1, movlw_hi_2, movlw_lo_1, movlw_lo_2
    printOperand(MI, 2, O); 
    O << ')'; 
    return;
    break;
  }


  // Fragment 3 encoded into 2 bits for 4 unique commands.
  switch ((Bits >> 22) & 3) {
  default:   // unreachable.
  case 0:
    // AndWF, OrWF, XOrWF, addwf_1, addwf_2, addwfc
    O << ", F"; 
    return;
    break;
  case 1:
    // MOV8rr, copy_fsr, copy_w, movwf, movwf_1, movwf_2, restore_fsr0, resto...
    return;
    break;
  case 2:
    // MOV8wr
    O << ",BANKED"; 
    return;
    break;
  case 3:
    // movf, movf_1, movf_1_1, movf_2
    O << ", W"; 
    return;
    break;
  }

}


/// getRegisterName - This method is automatically generated by tblgen
/// from the register set description.  This returns the assembler name
/// for the specified register.
const char *PIC18F4455AsmPrinter::getRegisterName(unsigned RegNo) {
  assert(RegNo && RegNo < 18 && "Invalid register number!");

  static const unsigned RegAsmOffset[] = {
    0, 3, 8, 13, 20, 23, 26, 29, 32, 35, 38, 41, 44, 47, 
    50, 55, 62, 0
  };

  const char *AsmStrs =
    "BS\000FSR1\000FSR2\000PCLATH\000R0\000R1\000R2\000R3\000R4\000R5\000R6\000"
    "R7\000R8\000R9\000FSR0\000STATUS\000WREG\000";
  return AsmStrs+RegAsmOffset[RegNo-1];
}


#ifdef GET_INSTRUCTION_NAME
#undef GET_INSTRUCTION_NAME

/// getInstructionName: This method is automatically generated by tblgen
/// from the instruction set description.  This returns the enum name of the
/// specified instruction.
const char *PIC18F4455AsmPrinter::getInstructionName(unsigned Opcode) {
  assert(Opcode < 85 && "Invalid instruction number!");

  static const unsigned InstAsmOffset[] = {
    0, 4, 14, 27, 36, 45, 50, 65, 79, 92, 106, 123, 133, 146, 
    151, 168, 183, 189, 195, 200, 207, 214, 221, 228, 235, 242, 249, 254, 
    259, 265, 272, 290, 296, 302, 310, 318, 325, 333, 341, 348, 356, 364, 
    371, 377, 387, 396, 403, 417, 422, 429, 438, 445, 451, 462, 473, 484, 
    495, 501, 509, 517, 522, 539, 552, 565, 575, 585, 595, 605, 616, 631, 
    639, 647, 656, 663, 671, 679, 687, 695, 703, 711, 720, 728, 736, 745, 
    752, 0
  };

  const char *Strs =
    "PHI\000INLINEASM\000PROLOG_LABEL\000EH_LABEL\000GC_LABEL\000KILL\000EXT"
    "RACT_SUBREG\000INSERT_SUBREG\000IMPLICIT_DEF\000SUBREG_TO_REG\000COPY_T"
    "O_REGCLASS\000DBG_VALUE\000REG_SEQUENCE\000COPY\000ADJCALLSTACKDOWN\000"
    "ADJCALLSTACKUP\000AndFW\000AndWF\000CALL\000MOV8rr\000MOV8rs\000MOV8rw\000"
    "MOV8sr\000MOV8sw\000MOV8wr\000MOV8ws\000OrFW\000OrWF\000Retlw\000Return"
    "\000SELECT_CC_Int_ICC\000XOrFW\000XOrWF\000addfw_1\000addfw_2\000addfwc"
    "\000addlw_1\000addlw_2\000addlwc\000addwf_1\000addwf_2\000addwfc\000and"
    "lw\000br_uncond\000copy_fsr\000copy_w\000load_indirect\000movf\000movf_"
    "1\000movf_1_1\000movf_2\000movlw\000movlw_hi_1\000movlw_hi_2\000movlw_l"
    "o_1\000movlw_lo_2\000movwf\000movwf_1\000movwf_2\000orlw\000pic18f4455b"
    "rcond\000restore_fsr0\000restore_fsr1\000save_fsr0\000save_fsr1\000set_"
    "fsrhi\000set_fsrlo\000set_pclath\000store_indirect\000subfw_1\000subfw_"
    "2\000subfw_cc\000subfwb\000sublw_1\000sublw_2\000sublw_3\000sublw_4\000"
    "sublw_5\000sublw_6\000sublw_cc\000subwf_1\000subwf_2\000subwf_cc\000sub"
    "wfb\000xorlw\000";
  return Strs+InstAsmOffset[Opcode];
}

#endif
